#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <wiringPi.h>
#include <wiringPiI2C.h>
#include "display.h"
#include "font.h"

int i2c;

u_int8_t memory[1024] = {
	0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x00, 0x08, 0x18, 0x38, 0x78, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x78, 0x38, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x83, 0x87, 0x83, 0x81, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0xff, 
	0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x81, 0xc1, 0xe1, 0xc1, 0x81, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x18, 0x1c, 0x1e, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x1e, 0x1c, 0x18, 0x10, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
	0xc0, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff
};

//      writes the unit to the display
//      bool dl chooses the row
//      and bool kbytes chooses the unit
void writeUnit(bool kbytes, bool dl) {
    if (kbytes && dl) {
        writeString("kB", 1, 103);
        writeString("s", 2, 106);
    } 
    else if (!kbytes && dl) {
        writeString("MB", 1, 103);
        writeString("s", 2, 106);
    } 
    else if (kbytes && !dl) {
        writeString("kB", 5, 84);
        writeString("s", 6, 87);
    } 
    else if (!kbytes && !dl) {
        writeString("MB", 5, 84);
        writeString("s", 6, 87);
    }
}

void writeDownload(float dl) {
    writeSpeed(dl, true);
}

void writeUpload(float ul) {
    writeSpeed(ul, false);
}

void writeSpeed(float speed, bool dl) {
    int col_start;
    int col_end;
    int seg_start;
    int seg_end;
    char speedString[8];

    // sprintf is used to convert float -> char array
    // for easier handling
    sprintf(speedString, "%.1f", speed);
    int speed_length = strlen(speedString);
    
    // bool dl selects if the speed is written on the lower or upper row
    if (dl) {
        col_start = 29;
        col_end = 100;
        seg_start = 1;
        seg_end = 2;
    } else {
        col_start = 10;
        col_end = 81;
        seg_start = 5;
        seg_end = 6;
    }

    SSD1306_command(0x21);
    SSD1306_command(col_start);
    SSD1306_command(col_end);

    SSD1306_command(0x22);
    SSD1306_command(seg_start);
    SSD1306_command(seg_end);

    // some padding according to length of the speed value
    if (speed_length == 4) {
        drawPadding(15);
    } else if (speed_length == 3) {
        drawPadding(30);
    }

    // ASCII_BIG font is 14 pixels high so write the upper
    // 7 pixels of all characters first
    for ( int x = 0; x < speed_length; x++){
        int c;
        if (speedString[x] == '.') {
            c = 10;
        } else {    
            // ascii to int conversation by subtracting '0'
            c = speedString[x] - '0'; 
        }

        for (int i = 0; i < 12; i++) {
            SSD1306_data(ASCII_BIG[c][i]);
        }
        // padding between all characters except the last one
        if (x != speed_length -1) {
            drawPadding(3);
        }
    }

    // some padding according to length of the speed value
    if (speed_length == 4) {
        drawPadding(15);
    } else if (speed_length == 3) {
        drawPadding(30);
    }

    // write the lower 7 pixels
    for ( int x = 0; x < speed_length; x++){
        int c;
        if (speedString[x] == '.') {
            c = 10;
        } else {
            // ascii to int conversation by subtracting '0'
            c = speedString[x] - '0';
        }
        for (int i = 12; i < 24; i++) {
            SSD1306_data(ASCII_BIG[c][i]);
        }
        // padding between all characters except the last one
        if (x != speed_length -1) {
            drawPadding(3);
        }
    }
}

// writes x amount on empty data
void drawPadding(int x) {
    for (int i = 0; i < x; i++) {
        SSD1306_data(0x00);
    }
}

// writes single integer with ASCII_BIG font
void writeInt(int num, int line, int x) {
    int y = line * 8;
    int col = x;
    setPointer(col, y);
    for (int i = 0; i < 24; i++) {
        if (i == 12) setPointer(col = x, y += 8);
        SSD1306_data(ASCII_BIG[num][i]);
        setPointer(++col, y);
    }
}

void writeString(char* str, int line, int col) {
    for (int i = 0; i < strlen(str); i++) {
        writeSmallChar(str[i], line, col += 6);
    }
}

void writeSmallChar(char c, int line, int col) {
    int y = line * 8;
    setPointer(col, y);
    for (int i = 0; i < 5; i++) {
        SSD1306_data(ascii_small[c-32][i]);
        setPointer(++col, y);
    }
}

// toggles pixel on or off
void togglePixel(int x, int y) {
    setX(x);
    setY(y);

    // 2d array indexing
    int index = (WIDTH * (y / 8)) + x;

    int current_byte = memory[index];

    // shift 1 bit left by the result of the mod operation
    // xor the result with with the current memory reading to
    // toggle the bits
    int data = (1 << (y % 8)) ^ current_byte;
    memory[index] = data;

    SSD1306_data(data);
}

// sets pointer to column x in page y
void setPointer(int x, int y) {
    setX(x);
    setY(y);
}

// set pointer to certain column
void setX(int x) {
    SSD1306_command(0x21);
    SSD1306_command(x);
    SSD1306_command(x);
}

// set pointer to certain page
void setY(int y) {
    int page = y / 8;
    SSD1306_command(0x22);
    SSD1306_command(page);
    SSD1306_command(page);
}

// send command to the SSD1306
void SSD1306_command(int command) {
    wiringPiI2CWriteReg8(i2c, 0x00, command);
}

// send byte to be displayed
void SSD1306_data(int data) {
    wiringPiI2CWriteReg8(i2c, 0x40, data);
}

int initSSD1306() {

    if(wiringPiSetup() < 0) {
        perror("Failed wiringPi setup");
        return -1;
    }

    i2c = wiringPiI2CSetup(0x3C);

    if (i2c < 0) {
        perror("Failed I2C setup");
        return -1;
    }

    // https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf

    // Software Initialization Flow Chart (page 64)
    SSD1306_command(0xAE); // display OFF (page 28)

    // Set MUX ratio (page 31)
    SSD1306_command(0xA8); 
    // value for MUX ratio " The power on reset value is 63 (i.e. 64MUX)." (page 22)
    SSD1306_command(0x3F);

    // set display offset (page 31)
    SSD1306_command(0xD3);
    // "The value is reset to 00h after RESET." (page 31)
    SSD1306_command(0x00);

    // set display start line (page 36)
    SSD1306_command(0x40);

    // set segment re-map (page 36)
    SSD1306_command(0xA1);

    // set COM output scan direction "C0h normal mode (RESET) Scan from COM0 to COM[N â€“1]" (page 31)
    SSD1306_command(0xC8);

    // set COM pins hw configuration
    SSD1306_command(0xDA);
    // (page 40) 0b00110010
    SSD1306_command(0x12);

    // set contrast control (page 28)
    SSD1306_command(0x81);
    // contrast value "Contrast increases as the value increases." (page 28)
    SSD1306_command(0xFF);

    // disable entire display on (page 28)
    SSD1306_command(0xA4);

    // set normal display (page 28)
    SSD1306_command(0xA6);

    // set display clock divide (page 32)
    SSD1306_command(0xD5); 
    // value for display clock divide (page 32)
    SSD1306_command(0x80); 

    // enable charge pump regulator (page 62)
    SSD1306_command(0x8D);
    // Enable Charge Pump
    SSD1306_command(0x14);

    // set the display on
    SSD1306_command(0xAF);

    // set memory addressing mode (page 34)
    SSD1306_command(0x20);
    // horizontal addressing mode (page 35)
    SSD1306_command(0x00);

    // reset the pointer to 0,0
    SSD1306_command(0x21);
    SSD1306_command(0x0);
    SSD1306_command(0x7F);
    // reset the pointer to 0,0
    SSD1306_command(0x22);
    SSD1306_command(0x00);
    SSD1306_command(0x07);

    // draw the borders and arrows
    for (int i = 0; i < 1024; i++) {
        SSD1306_data(memory[i]);
    }

    return 0;
}
